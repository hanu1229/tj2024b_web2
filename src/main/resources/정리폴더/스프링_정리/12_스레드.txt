[ 용어 정리 ]
    01. 프로그램 : 코드(명령어)의 집합
    02. 프로세스 : 실행중인 프로그램
    03. 멀티 태스킹 : 하나의 프로그램에서 두가지 이상의 작업을 동시 처리
    04. 멀티 프로세스 : 운영체제가 동시에 여러개의 프로세스를 생성하여 처리
        ├─ 멀티 프로세스는 프로그램 단위의 멀티 태스킹
        └─ 멀티 스레드는 프로그램 내부에서의 멀티 태스킹

[ 스레드 ]
    01. 정의
        ├─ 프로세스내에서 실행되는 작업 단위
        └─ 각 프로세스는 최소 1개의 스레드를 포함하고 있음
            └─자바는 main함수가 main스레드를 포함함으로써 하나의 프로세스(프로그램)을 만들 수 있다.
                └─ 자바스크립트에 스레드(main함수)가 존재하지 않는 이유 : 브라우저(프로그램/스레드)가 JS를 읽어드리기 때문이다.
    02. 목적
        └─ 코드(명령어)를 읽어드리고 CPU가 처리한다.
    03. 자바에서의 스레드
        └─ main함수 : public static void main(String[] args) {} 에는 main스레드가 내장되어 있다.

[ 멀티 스레드 ] - Spring에서는 @ASYNC 어노테이션을 쓰면 끝
    01. 정의
        └─ main함수(스레드) 외 새로운 작업 스레드를 생성하는 경우
    02. 목적
        └─ 병렬 처리를 위해서 사용한다.
    03. 사용처
        ├─ 동기화/비동기화 처리(async)
        ├─ 채팅(Socket)/파일처리/REST API/JDBC
        └─ 등등
    04. 사용법
        ├─ Thread 클래스
        │   ├─ 새로운 스레드를 생성할 때 사용되는 클래스
        │   └─ 다른 클래스를 상속받을 수 없다.
        │      └─ 주요 메소드
        │          ├─ run()    : 새로운 스레드가 처리(실행)할 코드를 정의
        │          └─ start()  : 새로운 스레드를 실행
        ├─ Runnable 클래스
        │   ├─ 새로운 스레드를 생성할 때 사용되는 인터페이스
        │   └─ 다른 클래스를 상속받을 수 있다.
        │       └─ 주요 메소드
        │           ├─ run()    : 새로운 스레드가 처리(실행)할 코드를 정의
        │           └─ start()  : 새로운 스레드를 실행
        ├─ Thread 상속
        │   └─ class 클래스명 extends Thread { @Override run() {} }
        ├─ implements Runnable 구현(구현 객체)
        │   └─ class 클래스명 implements Runnable { @Override run() {} }
        └─ 익명 구현체 --> run()이 익명체
            └─ new Thread( new Runnable() { @Override run() {} } );

    05. 용어
        ├─ 클래스와 인터페이스의 차이
        │   ├─ 클래스
        │   │   ├─ 함수의 구현
        │   │   ├─ 멤버변수O
        │   │   └─ 인스턴스(객체)생성 가능(new 가능)
        │   └─ 인터페이스
        │       ├─ 함수의 선언(추상, 버전에 따라 구현도 가능)
        │       ├─ 멤버변수X (단, 상수변수는 가능)
        │       └─ 인스턴스(객체)생성 불가능(new 불가능), 익명객체로 구현하면 가능
        ├─ extends(상속)과 implements(구현)의 차이
        │   ├─ extends는 하나의 클래스만 받을 수 있다(클래스 상속)
        │   └─ implements는 여러개의 인터페이스만 받을 수 있다(인터페이스 상속)
        ├─ 구현 객체
        │   └─ 추상메소드를 갖는 인터페이스를 구현한 클래스의 객체
        └─ 익명 객체
            ├─ 추상메소드를 즉석에서 구현한 객체
            └─ new 인터페이스명() { 추상메소드(); }

    06. 동기화 VS 비동기화
        ├─ 동기화 키워드 : synchronized
        ├─ 동기화 사용법
        │   ├─ 방법1 : 메소드 선언부의 반환타입 앞에 'synchronized' 키워드 작성
        │   └─ 방법2 : synchronized(this) { } 블럭을 함수 안에서 사용
        └─ 동기화 목적
            └─ 멀티 스레드에서 하나의 자원을 동시에 접근할 때 충돌 방지

    07. 스레드풀(Thread Pool)
        ├─ 정의
        │   ├─ 미리 일정한 개수의 스레드를 생성하고 필요에 따라 재사용하는 방식
        │   └─ 작업이 들어올 때마다 새로운 스레드가 아닌 기존 스레드를 재사용
        ├─ 목적
        │   ├─ 스레드 재사용
        │   ├─ 자원 효율성
        │   ├─ 과부하 방지
        │   └─ 등등
        ├─ 구조예시
        │   └─ 큐(Queue)
        │       └─ 작업의 순서를 요청 순서대로 자료를 구조화하는 방법
        ├─ 실생활에서
        │   └─ 콜센터 : 콜센터 지점[스레드풀], 전화를 받는 사람 [스레드]
        ├─ 사용처
        │   ├─ 톰켓(서블릿)
        │   ├─ JDBC
        │   ├─ 파일처리
        │   └─ 등등
        └─ 사용법
            ├─ 정해진 스레드 개수로 스레드풀을 생성한다.
            │   └─ ExecutorService 변수명 = Executors.newFixedThreadPool(스레드 수);
            ├─ 스레드풀에 스레드를 등록한다.
            │   └─ 변수명.submit(등록할스레드);
            └─ 스레드풀 종료
                └─ 변수명.shutdown();

[ 스프링 스레드 ]
    01. 사용법
        ├─ AppStart클래스 위에 '@EnableAsync'어노테이션을 추가하여 톰캣 스레드와 별도의 비동기 기능을 활성화
        ├─ 비동기 기능을 적용할 메소드 위에 '@Async'어노테이션을 추가하여 비동기 메소드를 정의
        └─ 동기를 적용하고 싶을 때 기능을 적용할 메소드 반환타입 앞에 'synchronized'키워드를 붙임

[ 스프링 스레드풀 ]
    01. 정의
        └─ 스프링은 기본적으로 스레드풀을 사용
    02. 목적
        └─ 커스텀을 이용하여 스레드풀 정의 가능

[ 스프링 스케줄링 ]
    01. 정의
        └─ 일정한 간격으로 특정 메소드를 자동 실행할 수 있는 기능을 제공
    02. 목적
        ├─ 백그라운드(백엔드)에서 자동 실행
        ├─ 자동화 처리를 구현(공장)
        ├─ 특정 시간에 자동 업무처리
        └─ 등등
    03. 사용법
        ├─ AppStart클래스 위에 '@EnableScheduling'어노테이션을 추가하여 스케줄링 기능 활성화
        └─ 스케줄링을 적용할 메소드 위에 '@Schedyled(패턴)'어노테이션을 추가하여 자동 메소드 실행
    04. 사용처
        ├─ 로그 기록
        ├─ 백업 처리
        ├─ 데이터 동기화 처리
        ├─ 데이터베이스 자동화 처리
        └─ 주기별 이메일 자동 전송 기능
    05. 패턴
        ├─ fixedRate
        │
        ├─ fixedDelay
        │
        └─ cron (권장)
            ├─ cron (표현식) 패턴
            │   └─ 기본 생김새 : @Scheduled("* * * * * *");
            │       └─ 첫번째 * : 초 --> 0 ~ 59
            │       ├─ 두번째 * : 분 --> 0 ~ 59
            │       ├─ 세번째 * : 시 --> 0 ~ 23
            │       ├─ 네번째 * : 일 --> 1 ~ 31
            │       ├─ 다섯번째 * : 월 --> 0 ~ 11
            │       ├─ 여섯번쨰 * : 요일 --> 0 ~ 6 (일요일 = 0)
            │       └─ ? : 지정하지 않은 자릿수 뜻(와일드 카드)
            └─ 예시
                ├─ @Scheduled(cron = "*/5 * * * * *");  : 지정한(5)초 마다 실행
                ├─ @Scheduled(cron = "0 */10 * * * *"); : 지정한(10)분 마다 실행
                ├─ @Scheduled(cron = "0 0 */1 * * *");  : 지정한(1)시간 마다 실행
                ├─ @Scheduled(cron = "0 0 9 1 * *");    : 매월 1일 오전 9시에 실행
                ├─ @Scheduled(cron = "0 0 11 ? * 0");   : 일요일마다 오전11시에 실행
                └─ @Scheduled(cron = "0 0 11 * * 0,6"); : 주말(일/토)마다 오전11시에 실행

    06. 주의할점
        ├─ 백그라운드 처리 이므로 REST API response가 안된다.
        ├─ REST API에서 강제로 실행은 가능
        ├─ http 프로토콜
        │   └─ 연결상태를 유지 X
        └─ ws(WebSocket) 프로토콜
            └─ 연결 상태를 유지 O

